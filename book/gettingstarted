\chapter{Getting Started}

There are two parts to beginning work on compilers. One is understanding
the goal. The other is installing the tools.

\section{What are Trying to Do?}

Compiling is translating a human readable source code language
into something else called the target language.

\subsection{gcc}

Traditionally, the target language is assembly. The most famous
current compiler following this tradition is gcc. Given a C program,
it will generate assembly, then quietly assemble and link that, so you
receive an executable. How portable will the executable be? Not very.

    #include <stdio.h>

    int main(int argc, char *argv[]) {
        printf("Hello %s\n", "Rob");
        return 12;
    }

Compile and run:

    gcc hello.c -o hello
    ./hello

\subsection{dot}

There are lots of other related tools which don't generate assembly,
many which don't make anything that actually runs. One of my favorites
is Dot (see https://graphviz.org/). It takes a descriptive source
language and generates image output in formats like png, jpeg, gif,
pdf, and others.

If you install graphviz on your system, you can save this as family.dot
in your favorite text editor:

    digraph { Mom -> Me }

To compile it, run:

    dot -Tpng -o family.png family.dot

Then you will have png output in family.png showing this tiny excerpt
of my family tree.

\subsection{TeX}

TeX is a language for typesetting written by Donal Knuth (who also
wrote a famous set of books giving the complete state of the art of
software circa 1972). You can write macros in it. Leslie Lamport
wrote a whole bunch of really useful ones which he called LaTeX. In TeX,
you type commands that describe documents and the contents of those
documents into a text editor. Here is an example:

    \documentclass{article}
    \title{A Sample}
    \author{Phil Crow}
    \begin{document}
    \maketitle

    This is a simple sample of a LaTeX article.

    \end{document}

Save that as article.tex and run

    pdflatex article.tex

to make a PDF. This is my preferred mode of PDF generation.

\subsection{lilypond}

Some bright boys that met in a youth orchestra thought it would be
cool to use TeX to engrave sheet music. They developed lilypond,
which long ago gave up on using TeX. The syntax still looks a lot
like TeX.

Given a text file called scale.ly with this content:

    \score{
        {
            c' d' e' f' g' a' b' c''
        }
        \layout{}
        \midi{}
    }
    \version "2.18.2"

To generate sheet music as a PDF type:

    lilypond scale.ly

Since the layout and midi commands are there, you also get scale.midi
with a grand piano playing the music.

As you may have noticed, I am rather obsessed with tools that take
source from a text file and produce something useful.

\subsection{Typescript}

JavaScript is one of my favorite languages. Since the browser takes
care of running it, I can get all kinds of spectacular behaviors
for users with it, often in only a few lines. It also reminds me
of other languages I have enjoyed in the past, like Perl.

There are those who have a dislike for languages like this in general
(loosely typed, being the main complaint). Many different groups of
JavaScript haters have developed alternatives.

One of those is Typescript. You write in Typescript, then convert
it to JavaScript, since that is the only language the browsers understand.

Languages that convert one source language to another are called transpilers.

I don't have this installed, if you want to play with it see

    https://www.typescriptlang.org/play/

\subsection{Sass}

CSS is the language which controls the appearance of web pages. It is
also often maligned. CSS is descriptive, that is it has no conditionals
or loops. As with JavaScript, many have tried to improve it by making
a super-language which is more expressive, but can be transpiled to CSS.
The one I have heard the most about is Syntactially Awesome Style Sheets
(Sass).

I don't have this installed, to read more about it see

    https://sass-lang.com/guide

\subsection{Virtual Machines}

Returning to languages that run, we find that an executable for the
system where the compiler ran is not the only option. Some languages
target a virtual machine.

In the late 1970s computers were a hot new thing. Size was coming down.
You no longer needed a room (with its own air conditioner) to house one.
The problem was that everyone was building them, each using a different
architecture. Infocom wanted to produce games. The problem was how to
make them run on whatever system the customer bought.

Joel Berez and Marc Blank answered that question by developing a
device indpendent virtual machine called the Z-Machine. For each new
computer that came out, a small number of developers at Infocomm
would port that to the new platform. All the games compiled to its
format. Once the port was finished the whole line of games would
work on the new system.

There were virtual machines before this. And, there is a famous one
that came later called the Java Virtual Machine. The idea is always
the same. Compile the source code to the format of the virtual machine.
Port the virtual machine to all platforms of interest. All the programs
run on all the platforms.

\subsection{Summary}

Compilers take source language from a text file that humans can read
and write. They turn that into another language or format, usually
one that humans would find hard to read, but that the computer can
render or run.

\section{What Tools will we Use?}

Our goal in this course is to implement a small language, or really
a series of small lanuages of increasing utility (and corresponding
complexity). To do this, we will describe out languages with ANTLR4.

To follow along, you need to install (in order) a Java Development
Kit (JDK), gradle, and ANTLR4. You don't have to use these tools.
I have learned a lot about compilers by reading books and translating
their examples from the language in the book to the language I prefer.
You could do the same, but I won't spend time worrying about you then.

Visit https://openjdk.org/ if you need to install Java.

Visit https://gradle.org/ if you need to install gradle.

Visit https://www.antlr.org/ to install ANTLR4.

If you want to generate assembly, you need an assembler. Good news:
gcc has that inside it. That's one choice. I also have a little
pseudo-assembler I wrote to give a feel for assembly without worrying
about actual chip instructions.
