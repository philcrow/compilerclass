Review Student Work

Emitting Take One (My solution to exercise 1)

Exercise 1 asks for a new tree visitor using String as the generic type.
This allows the top level visitPrintExpr method to emit the program
in postfix notation ready for the dc unix tool.

    import java.util.HashMap;
    import java.util.Map;
    
    public class DcEmitter extends ExprBaseVisitor<String> {
        // symbol table
        Map<String, String> symbolTable = new HashMap<>();
    
        @Override
        public String visitPrintExpr(ExprParser.PrintExprContext ctx) {
            String value = visit(ctx.expr());
            System.out.println(value + "p");
            return "";
        }
    
        @Override
        public String visitAssign(ExprParser.AssignContext ctx) {
            String id = ctx.ID().getText(); // get the variable name
            String value = visit(ctx.expr()).trim();  // walk the expression subtree for value
    
            symbolTable.put(id, value);     // store the variable in the symbol table
            return "";
        }
    
        @Override
        public String visitInt(ExprParser.IntContext ctx) {
            return ctx.INT().getText() + "\n";
        }
    
        @Override
        public String visitId(ExprParser.IdContext ctx) {
            String id = ctx.ID().getText();
    
            if (symbolTable.containsKey(id)) {
                return symbolTable.get(id) + "\n";
            }
            else {
                System.err.println( "undefined symbol: " + id + " using 0");
                return "";
            }
        }
    
        @Override
        public String visitMulDiv(ExprParser.MulDivContext ctx) {
            String left = visit(ctx.expr(0));
            String right = visit(ctx.expr(1));
    
            if (ctx.op.getType() == ExprParser.MUL) {
                return left + right + "*\n";
            }
            else {
                return left + right + "/\n";
            }
        }
    
        @Override
        public String visitAddSub(ExprParser.AddSubContext ctx) {
            String left = visit(ctx.expr(0));
            String right = visit(ctx.expr(1));
    
            if (ctx.op.getType() == ExprParser.ADD) {
                return left + right + "+\n";
            }
            else {
                return left + right + "-\n";
            }
        }
    
        @Override
        public String visitParens(ExprParser.ParensContext ctx) {
            return visit(ctx.expr());
        }
    }

All of the methods have the same signatures, but they return String now.
From the bottom, visitParens is otherwise unchanged.

In visitAddSub, we collect the children's output, use the same if to pick
between ADD and SUBtract. But the output is just the concatenation of child
output with the addition of the operator. This is the meaning of postfix:
the operands come first, then the operator. We see a similar change in
visitMulDiv.

For visitId we still retreive the name of the ID as before. But, now the symbol
table itself stores the values as Strings. All we need to return is that value
with a newline.

Similarly, visitInt asks for the INT token, but this time uses it directly
as a String instead of converting it to a number. It too remembers to add
a newline.

In visitAssign, we need to be careful with whitespace. When we visit the
expression child, it will give us a string with a newline on the end.
We don't want that in the symbol table, so we trim it. Otherwise, we
use the value as presented. That could be as set of lines. We just don't want
the trailing newline.

Finally, at the top visitPrintExpr simply prints what the children have
returned with a literal p and a final newline (using println). The dc tool
uses p to mean pop the stack and print. When a calculation is finished,
the result will be on the top of the stack. If you don't pop and print,
you just won't be able to see it sitting there.

From Abstract Syntax Tree to a Decorated Parse Tree

The tree that ANTLR4 builds for us to walk is an expression of the grammar's
understanding of our source program. For simple languages, we can use
that directly. As things get more complicated, we need something more.

The post-parsing problems we need to eventually solve include: type checking
(Is it really legal to use that variable or literal in that expression?),
memory allocation (Where will this value live in the target language memory?)
forward references (Where is the method the constructor just called?), and others.

A lot of this is about meaning. Many sentences that are grammatically correct
don't actually make sense. "John ran home," is fine, but "John ran church,"
doesn't quite make sense, even though it has the same grammatical structure. 
Noticing errors like this in source languages is called semantic analysis.
For that we build a new tree (or directed graph) called an annotated parse
tree, also known as a decorated parse tree.

We record extra information in the decorated tree to enforce semantic rules.

We also need to think about the target language. So, our decorated tree needs
to have enough information to aid code generation for the language we have in
mind. Traditionally, that language is assembly of some kind, either the real
thing or a byte code machine like the JVM.

Finally, we want to deliver quality errors messages at every stage.
We need to record source code line numbers in the tree, so that we
can print them when an exception occurs.

We are not going to do all of this at once. We will start small and build.
This is not just a strategy for college courses. In the work place we want
to build incrementally so we can: (1) see progress, (2) verify that we
are doing the right thing for our users, (3) build only what is needed,
(4) keep out sanity by not making things too complex all at once.

We saw the starting point for this decorated tree when we made the emitter for dc.
From the ANTLR4 parse tree, each visit method returns an object. For dc, we simply
re-emitted the tokens from our source language (after recording and discarding
assignment statements and later replacing variables with those values).
Where we returned String, we need to return a TreeNode that can become part of
a decorated parse tree. This will have room for flow of control (like if and while)
and for memory management (like arrays and record structures like object instances).

While a decorated parse tree is essential for emitting code in a target language,
it is also the key to interpretting the language. In my career I have only
emitted target code as an exercise, but I have written interpretters for production use.
Therefore, I want to start by building a tree that lets us interpret the language.
This is actually a hybrid approach. Truly interpretted languages (like bash or
another command line shell) don't look ahead. They simply run the commands as they
see them. Our interpretter is more robust, because the whole program is built
into the decorated tree. Eventually that allows us to do things like run
routines (methods, functions, etc.) which are defined later in the source file.


