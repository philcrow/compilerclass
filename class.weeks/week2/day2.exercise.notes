Emitting Take One

Exercise 1 asks for a new tree visitor using String as the generic type.
This allows the top level visitPrintExpr method to emit the program
in postfix notation ready for the dc unix tool.

    import java.util.HashMap;
    import java.util.Map;
    
    public class DcEmitter extends ExprBaseVisitor<String> {
        // symbol table
        Map<String, String> symbolTable = new HashMap<>();
    
        @Override
        public String visitPrintExpr(ExprParser.PrintExprContext ctx) {
            String value = visit(ctx.expr());
            System.out.println(value + "p");
            return "";
        }
    
        @Override
        public String visitAssign(ExprParser.AssignContext ctx) {
            String id = ctx.ID().getText(); // get the variable name
            String value = visit(ctx.expr()).trim();  // walk the expression subtree for value
    
            symbolTable.put(id, value);     // store the variable in the symbol table
            return "";
        }
    
        @Override
        public String visitInt(ExprParser.IntContext ctx) {
            return ctx.INT().getText() + "\n";
        }
    
        @Override
        public String visitId(ExprParser.IdContext ctx) {
            String id = ctx.ID().getText();
    
            if (symbolTable.containsKey(id)) {
                return symbolTable.get(id) + "\n";
            }
            else {
                System.err.println( "undefined symbol: " + id + " using 0");
                return "";
            }
        }
    
        @Override
        public String visitMulDiv(ExprParser.MulDivContext ctx) {
            String left = visit(ctx.expr(0));
            String right = visit(ctx.expr(1));
    
            if (ctx.op.getType() == ExprParser.MUL) {
                return left + right + "*\n";
            }
            else {
                return left + right + "/\n";
            }
        }
    
        @Override
        public String visitAddSub(ExprParser.AddSubContext ctx) {
            String left = visit(ctx.expr(0));
            String right = visit(ctx.expr(1));
    
            if (ctx.op.getType() == ExprParser.ADD) {
                return left + right + "+\n";
            }
            else {
                return left + right + "-\n";
            }
        }
    
        @Override
        public String visitParens(ExprParser.ParensContext ctx) {
            return visit(ctx.expr());
        }
    }

All of the methods have the same signatures, but they return String now.
From the bottom, visitParens is otherwise unchanged.

In visitAddSub, we collect the children's output, use the same if to pick
between ADD and SUBtract. But the output is just the concatenation of child
output with the addition of the operator. This is the meaning of postfix:
the operands come first, then the operator. We see a similar change in
visitMulDiv.

For visitId we still retreive the name of the ID as before. But, now the symbol
table itself stores the values as Strings. All we need to return is that value
with a newline.

Similarly, visitInt asks for the INT token, but this time uses it directly
as a String instead of converting it to a number. It too remembers to add
a newline.

In visitAssign, we need to be careful with whitespace. When we visit the
expression child, it will give us a string with a newline on the end.
We don't want that in the symbol table, so we trim it. Otherwise, we
use the value as presented. That could be as set of lines. We just don't want
the trailing newline.

Finally, at the top visitPrintExpr simply prints what the children have
returned with a literal p and a final newline (using println). The dc tool
uses p to mean pop the stack and print. When a calculation is finished,
the result will be on the top of the stack. If you don't pop and print,
you just won't be able to see it sitting there.
